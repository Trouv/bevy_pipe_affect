<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>bevy_pipe_affect Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">bevy_pipe_affect Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bevy_pipe_affectwrite-systems-as-pure-functions"><a class="header" href="#bevy_pipe_affectwrite-systems-as-pure-functions"><code>bevy_pipe_affect</code><br>Write systems as pure functions</a></h1>
<p>Normally, Bevy systems perform some state changes as side effects.
This crate enables you to instead return <code>Effect</code>s as system output.</p>
<p><code>Effect</code>s define an ECS state transition.
All common ECS operations have one or more <code>Effect</code> types provided in the library.</p>
<p>These "systems with effects" can then be <code>.pipe(affect)</code>-ed.
The <code>affect</code> system will perform the state transition.</p>
<p>This enables a more functional code-style in <code>bevy</code> app development.
User-written systems can all be read-only, pure functions.
All mutability can be <em>piped out</em> of your code.</p>
<h2 id="this-book"><a class="header" href="#this-book">This book</a></h2>
<p>This book aims to provide a place for the following pieces of documentation:</p>
<ul>
<li>tutorials: lessons detailing the creation of simple games from start to finish</li>
<li>explanation: clarification of concepts and strategies employed by <code>bevy_pipe_affect</code>, including details about how it works and why</li>
<li>how-to guides: recommended solutions to common problems, as well as migration guides</li>
</ul>
<p>This book is not an API reference.
For that, please refer to <code>bevy_pipe_affect</code>'s documentation on <a href="https://docs.rs/bevy_pipe_affect/0.1.0/bevy_pipe_affect">docs.rs</a>. <!-- x-release-please-version --></p>
<p>While this book aims to be comprehensive, it should also be easy to maintain and up-to-date.
This is why, in consort with the API reference, documentation for <code>bevy_pipe_affect</code> aims to satisfy <a href="https://documentation.divio.com/">The Grand Unified Theory of Documentation</a>.
Furthermore, code snippets in this book are automatically tested by <code>bevy_pipe_affect</code>'s CI wherever possible with the help of <a href="https://github.com/tfpk/mdbook-keeper/">mdBook-Keeper</a>.
This should help inform maintainers when changes to the library have made documentation out-of-date.
Deployment of this book to github pages is also performed by <code>bevy_pipe_affect</code>'s CI automatically on new releases.</p>
<p>Splitting the documentation up this way means that docs are not necessarily meant to be read in order.
Some chapters are intended to be read while working on your own project, while others are meant to be more like studying material.
The following are good jumping-off points for beginners:</p>
<ul>
<li><a href="explanation/motivations.html"><em>Motivations</em> explanation</a></li>
<li><a href="https://docs.rs/bevy_pipe_affect/0.1.0/bevy_pipe_affect/effects/index.html"><em>effects</em> module api reference</a> (a list of effects and constructors provided by the library) <!-- x-release-please-version --></li>
</ul>
<h2 id="other-resources"><a class="header" href="#other-resources">Other resources</a></h2>
<p>This book is not suitable documentation for Bevy.
Some resources for learning Bevy include those listed on the <a href="https://bevyengine.org/learn">Bevy website</a>, as well as the unofficial <a href="https://bevy-cheatbook.github.io/">Bevy Cheat Book</a>.</p>
<p><code>bevy_pipe_affect</code>'s <a href="https://github.com/Trouv/bevy_pipe_affect/tree/v0.1.0">source code</a> is available on github. <!-- x-release-please-version -->
This repository also contains <a href="https://github.com/Trouv/bevy_pipe_affect/tree/v0.1.0/examples">cargo examples</a>, which can be run after cloning the repository using <code>$ cargo run --release --all-features --example example-name</code>. <!-- x-release-please-version -->
These examples may be difficult to follow on their own, and many of their strategies are described in this book.
When viewing these examples, be careful to checkout the correct git tag for the version of the library you are using.
Some changes may have been made to the library or to the examples on the <code>main</code> branch that are not released yet, and trying to apply these to the version of the library you are using can lead to errors.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>The pages of this book fall under the same license as the rest of the <code>bevy_pipe_affect</code> repository.
I.e., this book is dual-licensed under <a href="http://opensource.org/licenses/MIT">MIT</a> and <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a> at your option.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="motivations"><a class="header" href="#motivations">Motivations</a></h1>
<p>Scrawled here is basically a blog post on functional programming, Bevy, and why I made this library.
It may not be the most practical piece of documentation, but I hope it shines a light on some of the design choices for library users, and maybe even reaches out to others who are future FP+ECS enthusiasts.</p>
<h2 id="im-an-fp-shill-now"><a class="header" href="#im-an-fp-shill-now">I'm an FP shill now</a></h2>
<p>Here is a brief shill for writing FP Rust.
If you already are an FP shill, you can skip this.</p>
<p>Rust takes a lot of inspiration from purely functional languages like Haskell.
As a person who learned Rust before functional programming, I was intrigued to learn that most of its features that I found to be revelations turned out to be derivative.
Iterator chains, algebraic data types, sum-types used in place of <code>null</code> and exceptions, <code>?</code> operators, to name a few.
Similar things have been etched into purely functional languages for a long time.</p>
<p>I've written a lot of Rust professionally over the past few years, and gradually it has become obvious how beneficial it is to use these features.
Or, more than anything else, it has become obvious how beneficial it is to write pure functions with the aid of these features.</p>
<p>For the uninitiated, pure functions are those that are deterministic and have no side effects.
Like a function in mathematics, they are mere input and output, so they do not read or write anything from the state of the world at large.
A purely functional language, like Haskell, is one that only allows you to write pure functions.
This may seem limiting, but thanks to higher-order functions, plus the strength of FP's theoretical foundations in general, it really isn't.</p>
<p>Pure functions are easily unit tested, since you don't need to set up any state.
They are easy to compose without unexpected consequences.
Programs can become extremely complex through composition, but each component can be obvious and simple and predictable.
There's relief in functions that only have input and output, for both readers and writers of the code.</p>
<blockquote>
<p>Which function should perform this change?</p>
</blockquote>
<blockquote>
<p>Should the data this function uses be input or read from state?</p>
</blockquote>
<blockquote>
<p>Should the data this function calculates be output or written to state?</p>
</blockquote>
<p>If you're writing pure functions, these questions aren't just foregone conclusions, they are invalid.</p>
<p>So in my regular programming practice now, I go to great lengths to <em>at least</em> push the state reading/writing to the fringes of the program.
Even when designing a system of programs, I consider pushing the state to the fringes of the data flow at large.
This practice isn't that common in Bevy.</p>
<h2 id="practical-motivation"><a class="header" href="#practical-motivation">Practical motivation</a></h2>
<p>Now, like a true software-gamedev-hipster, I also shill Bevy.
The core framework of Bevy is an ECS among many great Rust ECSs, but I especially appreciate that its systems are mere functions.
Its system scheduler may be particularly attractive to FP shills as well.
It is declarative, it leverages higher-order functions for scheduling your systems, it provides system composition with piping and mapping, and it does its best to abstract away the parallel execution of systems safely.</p>
<p>However, the main way to interact with the world in vanilla Bevy is by writing systems that have side effects.
If you want to update a resource, you must parameterize a <code>ResMut</code>.
If you want to edit components in-place, you must query them <code>&amp;mut</code>-ably.
If you want to load an asset, you must interact with the internally mutable <code>AssetServer</code>.
Even if you do everything with <code>Commands</code>, not only do the intended effects require exclusive world access, you're still having a side effect on the command queue.</p>
<p>In my feable attempts to write more immutable systems, I would simply write systems that output messages, or bundles, and then have generic systems to handle these as pipe input and actually do the writing or spawning. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Component)]
</span><span class="boring">struct Health(u32);
</span>use bevy::prelude::*;

#[derive(Debug, PartialEq, Eq, Message)]
struct DeathMessage(Entity);

fn detect_deaths(query: Query&lt;(Entity, &amp;Health)&gt;) -&gt; Vec&lt;DeathMessage&gt; {
    query
        .iter()
        .flat_map(|(entity, health)| {
            if health.0 == 0 {
                Some(DeathMessage(entity))
            } else {
                None
            }
        })
        .collect()
}

fn write_messages&lt;M: Message&gt;(
    In(messages): In&lt;impl IntoIterator&lt;Item = M&gt;&gt;,
    mut writer: MessageWriter&lt;M&gt;,
) {
    messages.into_iter().for_each(|message| {
        writer.write(message);
    });
}

fn main() {
    bevy::ecs::system::assert_is_system(detect_deaths.pipe(write_messages));
}</code></pre></pre>
<p>So, in this example, I have a pure system <code>detect_deaths</code> that produces messages as output, and then a system that actually writes the messages <code>write_messages</code>.
I've gone from 0% of my systems being pure to 50%.
Since <code>write_messages</code> is generic, I can now write more pure systems that produce messages and reuse it.</p>
<p>Wouldn't it be nice if 100% of user-written systems could be pure?
If somebody provided all the systems you may ever need to do the "writing" so that you only have to worry about writing ECS effects declaratively?</p>
<p><code>bevy_pipe_affect</code> aims to provide these systems.
Or rather, a single system for all ECS mutation.
Her name is <code>affect</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">//! This test is mostly used to demonstrate testing in the book
</span><span class="boring">
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span><span class="boring">
</span>#[derive(Component)]
struct Health(u32);

#[derive(Debug, PartialEq, Eq, Message)]
struct DeathMessage(Entity);

fn detect_deaths(query: Query&lt;(Entity, &amp;Health)&gt;) -&gt; Vec&lt;MessageWrite&lt;DeathMessage&gt;&gt; {
    query
        .iter()
        .flat_map(|(entity, health)| {
            if health.0 == 0 {
                Some(DeathMessage(entity))
            } else {
                None
            }
        })
        .map(message_write)
        .collect()
}
<span class="boring">
</span><span class="boring">use bevy::ecs::system::RunSystemOnce;
</span><span class="boring">
</span><span class="boring">#[derive(Resource)]
</span><span class="boring">struct UnhealthyEntity(Entity);
</span><span class="boring">
</span><span class="boring">fn test_detect_deaths() {
</span><span class="boring">    let mut world = World::new();
</span><span class="boring">
</span><span class="boring">    // We still need to setup the initial state of the world.
</span><span class="boring">    let _setup = world
</span><span class="boring">        .run_system_once(
</span><span class="boring">            (|| {
</span><span class="boring">                command_spawn_and(Health(100), |_| {
</span><span class="boring">                    command_spawn_and(Health(0), |entity| {
</span><span class="boring">                        command_insert_resource(UnhealthyEntity(entity))
</span><span class="boring">                    })
</span><span class="boring">                })
</span><span class="boring">            })
</span><span class="boring">            .pipe(affect)
</span><span class="boring">            .pipe(ApplyDeferred),
</span><span class="boring">        )
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span><span class="boring">    // Now we can just assert against system output instead of state changes
</span><span class="boring">    let dead_entity_messages = world.run_system_once(detect_deaths).unwrap();
</span><span class="boring">
</span><span class="boring">    let UnhealthyEntity(entity) = world.get_resource::&lt;UnhealthyEntity&gt;().unwrap();
</span><span class="boring">
</span><span class="boring">    assert_eq!(
</span><span class="boring">        dead_entity_messages,
</span><span class="boring">        vec![message_write(DeathMessage(*entity))]
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn cargo_test_detect_deaths() {
</span><span class="boring">    test_detect_deaths()
</span><span class="boring">}
</span>
fn main() {
    bevy::ecs::system::assert_is_system(detect_deaths.pipe(affect));
}</code></pre></pre>
<p>Rather than returning a list of messages, <code>detect_deaths</code> now returns <code>MessageWrite</code>s, which is an <code>Effect</code>.
A <code>Vec</code> of <code>Effect</code>s is also an <code>Effect</code>.
Then, the <code>affect</code> system can take any <code>Effect</code> and do the necessary writing.
The user no longer has to write words like <code>mut</code> and <code>for</code>.</p>
<h2 id="theoretical-motivation"><a class="header" href="#theoretical-motivation">Theoretical motivation</a></h2>
<p>Bevy's system scheduling APIs are higher-order functions that allow you to register system-functions to the App.
We can basically think of these higher-order functions as taking functions with two arguments, a <code>SystemInput</code> and a <code>SystemParam</code>, and then having an output.
Technically there's an extra wrinkle to this for two reasons, but both are just a bit of sugar that carmelize down to these two arguments:</p>
<ul>
<li>the <code>SystemInput</code> can be omitted, but the Bevy scheduling traits just use the unit type <code>()</code> in these cases</li>
<li>the <code>SystemParam</code> can occupy more than 1 arguments to the function (or even 0), but the Bevy scheduling traits just convert these cases to a tuple <code>SystemParam</code></li>
</ul>
<p>This is elegant.
Our <code>SystemParam</code> argument not only serves as normal function input, but it also expresses to the higher-order scheduling APIs what <em>factor</em> of the world needs to be input to the system.
I say <em>factor</em> in the sense of algebraic data types.
In the language of algebraic data types, an ECS world is sort of like a <em>product</em> of component storages and resources, and our <code>SystemParam</code> identifies a <em>factor</em> of this <em>product</em>.
Again, the reality of Bevy is more complicated (this time, much more complicated) than this theoretical framework.</p>
<p>The <code>SystemParam</code> is even composable.
The <em>factor</em> of the world that a system gets as input can actually be a larger product of system params.
As in, it can be a tuple of other system params, which again, is what the sugar of multi-system-param-argument functions carmelizes into.
Pipe systems also leverage this fact by composing the <code>SystemParam</code>s of two systems into one.</p>
<p>So far nothing about this is functionally impure.
We have functions with two arguments and an output, the first argument is <code>SystemInput</code> which is parameterized by output of another system, the second argument is <code>SystemParam</code> which is parameterized by some data in the world.
The impurity arrives when we allow that data from the world to be mutable.
And of course, in vanilla Bevy, this is our only choice if we want to have any effect on the world other than heating up our computers.</p>
<p>Pure functions are just input and output.
We'd like to use the output instead of the side effects to have an effect on world data.
Hence the <code>Effect</code> types provided by <code>bevy_pipe_affect</code>, intended to be returned by user systems.</p>
<p><code>Effect</code>s, conceptually, are almost a reflection of <code>SystemParam</code>s.
Where <code>SystemParam</code>s allow systems to express what <em>factor</em> of the world should be read, <code>Effect</code>s allow systems to express what <em>factor</em> of the world should be written (and how).
Where <code>SystemParam</code>s have an identity in the form of <code>()</code> that requests no data from the world, <code>Effect</code>s also treat <code>()</code> as an identity that has no effect on the world.
Where <code>SystemParam</code>s offer composibility with product types and derives, <code>Effect</code>s offer composibility with product types, derives, and sum-types.</p>
<p>Yes, not only is <code>Effect</code> implemented for tuples of effects, it can also be derived for structs of <code>Effect</code>s and enums of <code>Effect</code>s.
The latter is not a reflection of <code>SystemParam</code> behavior.
After all, it's not that common that you want a system that accepts <em>either</em> system param A <em>or</em> system param B.
It's a different story for <code>Effect</code>s, as there are many situations where you want <em>either</em> effect A to happen <em>or</em> effect B to happen.
The composibility of <code>Effect</code>s is as algebraic as algebraic data types.</p>
<p>In vanilla Bevy, systems are functions that have a side effect on system params.
By <em>returning</em> effects instead, systems now have a more satisfying theoretical definition.
They are mappings from some <em>factor</em> of the world to a state transition.
Or, more abstractly, they are pure, deterministic declarations of world behavior.</p>
<h2 id="write-systems-as-pure-functions"><a class="header" href="#write-systems-as-pure-functions">Write systems as pure functions</a></h2>
<p>Of course, none of this is required with <code>bevy_pipe_affect</code>.
Nothing about it forces you to write pure systems, you could write an effectful system that pipes an <code>Effect</code> into the <code>affect</code> system.</p>
<p>If you choose to, you will enjoy many of the benefits of pure functions.
The consequences of your systems will be more obvious at a glance: they are in the system's return type.
If you need more specifics, their value will always be at the very bottom of your function body.
In general, these two facts make it more difficult for you to muddy your systems with effects.
You will be encouraged to separate the concerns of your systems even more than you already are.</p>
<p>And of course, unit tests are easier to write.
Instead of observing the effects your systems have on the Bevy world, you can just observe the output of your systems.
An example, testing the <code>detect_deaths</code> system written above:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">//! This test is mostly used to demonstrate testing in the book
</span><span class="boring">
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Health(u32);
</span><span class="boring">
</span><span class="boring">#[derive(Debug, PartialEq, Eq, Message)]
</span><span class="boring">struct DeathMessage(Entity);
</span><span class="boring">
</span><span class="boring">fn detect_deaths(query: Query&lt;(Entity, &amp;Health)&gt;) -&gt; Vec&lt;MessageWrite&lt;DeathMessage&gt;&gt; {
</span><span class="boring">    query
</span><span class="boring">        .iter()
</span><span class="boring">        .flat_map(|(entity, health)| {
</span><span class="boring">            if health.0 == 0 {
</span><span class="boring">                Some(DeathMessage(entity))
</span><span class="boring">            } else {
</span><span class="boring">                None
</span><span class="boring">            }
</span><span class="boring">        })
</span><span class="boring">        .map(message_write)
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span>use bevy::ecs::system::RunSystemOnce;

#[derive(Resource)]
struct UnhealthyEntity(Entity);

fn test_detect_deaths() {
    let mut world = World::new();

    // We still need to setup the initial state of the world.
    let _setup = world
        .run_system_once(
            (|| {
                command_spawn_and(Health(100), |_| {
                    command_spawn_and(Health(0), |entity| {
                        command_insert_resource(UnhealthyEntity(entity))
                    })
                })
            })
            .pipe(affect)
            .pipe(ApplyDeferred),
        )
        .unwrap();

    // Now we can just assert against system output instead of state changes
    let dead_entity_messages = world.run_system_once(detect_deaths).unwrap();

    let UnhealthyEntity(entity) = world.get_resource::&lt;UnhealthyEntity&gt;().unwrap();

    assert_eq!(
        dead_entity_messages,
        vec![message_write(DeathMessage(*entity))]
    );
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn cargo_test_detect_deaths() {
</span><span class="boring">    test_detect_deaths()
</span><span class="boring">}
</span><span class="boring">fn main() { test_detect_deaths() }</span></code></pre></pre>
<p>Over all, game logic just becomes easier to reason about, especially <em>ex post facto</em>.
I hope you enjoy writing systems this way, and that they bring you more joy when the time comes for you to maintain them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="output-and-effect-composition"><a class="header" href="#output-and-effect-composition">Output and Effect Composition</a></h1>
<p>This chapter will cover the ways that effects compose, starting with the most basic and getting more advanced.</p>
<h2 id="combined-effects"><a class="header" href="#combined-effects">Combined effects</a></h2>
<p>The canonical form of "effect composition" is the combined effect, which is simply a tuple of effects.
The <code>Effect</code> trait is implemented for tuples where each element of the tuple also implements <code>Effect</code>.
The <code>affect</code> system will perform their effects from left to right.</p>
<p>So, if you want a system that has 2 or more effects of heterogenous type, you can just return their tuple:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span>#[derive(Resource)]
struct Score(u32);

fn setup() -&gt; impl Effect {
    (
        command_spawn(Camera2d::default()),
        command_insert_resource(Score(0)),
    )
}
<span class="boring">fn main() { bevy::ecs::system::assert_is_system(setup.pipe(affect)) }</span></code></pre></pre>
<h2 id="effect-iterators"><a class="header" href="#effect-iterators">Effect iterators</a></h2>
<p><code>Effect</code> is implemented for a couple of important iterators, <code>Option</code> and <code>Vec</code>.
There's also the <code>affect_many</code> effect, which can wrap any iterator.</p>
<p>So, if you want a system that has 2 or more effects of homogenous type, you can return them as a <code>Vec</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">//! This test is mostly used to demonstrate testing in the book
</span><span class="boring">
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span><span class="boring">
</span>#[derive(Component)]
struct Health(u32);

#[derive(Debug, PartialEq, Eq, Message)]
struct DeathMessage(Entity);

fn detect_deaths(query: Query&lt;(Entity, &amp;Health)&gt;) -&gt; Vec&lt;MessageWrite&lt;DeathMessage&gt;&gt; {
    query
        .iter()
        .flat_map(|(entity, health)| {
            if health.0 == 0 {
                Some(DeathMessage(entity))
            } else {
                None
            }
        })
        .map(message_write)
        .collect()
}
<span class="boring">
</span><span class="boring">use bevy::ecs::system::RunSystemOnce;
</span><span class="boring">
</span><span class="boring">#[derive(Resource)]
</span><span class="boring">struct UnhealthyEntity(Entity);
</span><span class="boring">
</span><span class="boring">fn test_detect_deaths() {
</span><span class="boring">    let mut world = World::new();
</span><span class="boring">
</span><span class="boring">    // We still need to setup the initial state of the world.
</span><span class="boring">    let _setup = world
</span><span class="boring">        .run_system_once(
</span><span class="boring">            (|| {
</span><span class="boring">                command_spawn_and(Health(100), |_| {
</span><span class="boring">                    command_spawn_and(Health(0), |entity| {
</span><span class="boring">                        command_insert_resource(UnhealthyEntity(entity))
</span><span class="boring">                    })
</span><span class="boring">                })
</span><span class="boring">            })
</span><span class="boring">            .pipe(affect)
</span><span class="boring">            .pipe(ApplyDeferred),
</span><span class="boring">        )
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span><span class="boring">    // Now we can just assert against system output instead of state changes
</span><span class="boring">    let dead_entity_messages = world.run_system_once(detect_deaths).unwrap();
</span><span class="boring">
</span><span class="boring">    let UnhealthyEntity(entity) = world.get_resource::&lt;UnhealthyEntity&gt;().unwrap();
</span><span class="boring">
</span><span class="boring">    assert_eq!(
</span><span class="boring">        dead_entity_messages,
</span><span class="boring">        vec![message_write(DeathMessage(*entity))]
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn cargo_test_detect_deaths() {
</span><span class="boring">    test_detect_deaths()
</span><span class="boring">}
</span><span class="boring">fn main() { bevy::ecs::system::assert_is_system(detect_deaths.pipe(affect)); }</span></code></pre></pre>
<h2 id="effectout"><a class="header" href="#effectout">EffectOut</a></h2>
<p><code>bevy_pipe_affect</code> sort of hijacks bevy's system piping.
So, at first glance, it may seem like there's no way to go about typical system pipe usage while making effects.
The <code>EffectOut</code> type aims to give system piping back to the people.
It also provides some composibility of its own that may be useful beyond systems.
More on this in the following sections.</p>
<p>Structurally, it's just an <code>effect</code> field containing an effect, and an <code>out</code> field containing additional output.</p>
<p>You may be interested to know that the higher-order systems provided by <code>bevy_pipe_affect</code> actually only ever expect a type that can convert into <code>EffectOut</code>, not just a mere <code>Effect</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span>#[derive(Resource)]
struct Score(u32);

#[derive(Deref, DerefMut, Resource)]
struct StartTime(f32);

fn update_score(time: Res&lt;Time&gt;, start_time: Res&lt;StartTime&gt;) -&gt; EffectOut&lt;ResSet&lt;Score&gt;, f32&gt; {
    let level_time = time.elapsed_secs() - **start_time;
    effect_out(res_set(Score(level_time as u32)), level_time)
}

fn main() {
    bevy::ecs::system::assert_is_system(update_score.pipe(affect))
}</code></pre></pre>
<p>Notice that we can still pipe <code>update_score</code> into <code>affect</code>, even though <code>update_score</code> returns an <code>EffectOut</code> instead of an <code>Effect</code>.
However, be aware that <code>affect</code> will actually have an output too; the <code>f32</code> is passed along.
This would prevent us from scheduling the system (without further piping to drop the <code>f32</code>).
However, it is inconsequential if the <code>out</code> type is <code>()</code>.</p>
<h3 id="effectoutand_then"><a class="header" href="#effectoutand_then"><code>EffectOut::and_then</code></a></h3>
<p><a href="explanation/output-and-effect-composition.html#effectout"><code>EffectOut</code></a>s compose in a few different ways, with the main goal of letting users process the <code>out</code> field while continuing to collect effects.
For example, the <code>and_then</code> method takes a function for processing the <code>out</code> into another <code>Effect</code>/<code>EffectOut</code>, and returns an <code>EffectOut</code> with the <code>effect</code> <a href="explanation/output-and-effect-composition.html#combined-effects">combining the original/new effect</a>, and an <code>out</code> being the new output.</p>
<p>This code example shows <code>and_then</code> being used to process the <code>EffectOut</code> returned by one function into more effects:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span><span class="boring">// A simple marker component for players.
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Player&lt;const N: usize&gt;;
</span><span class="boring">// A logical component for player level.
</span><span class="boring">#[derive(Component, Deref, DerefMut)]
</span><span class="boring">struct FightLevel(u32);
</span><span class="boring">/// A simple message we can write with effects.
</span><span class="boring">#[derive(Message)]
</span><span class="boring">struct Log(String);
</span>/// Will be used as an intermediate result of the fight logic.
enum FightOutcome {
    Player1Wins,
    Player2Wins,
    Draw,
}

/// This is not a system! It describes the logic for the upcoming fight system and also has a logging effect.
fn fight_outcome(
    player_1: &amp;FightLevel,
    player_2: &amp;FightLevel,
) -&gt; EffectOut&lt;MessageWrite&lt;Log&gt;, FightOutcome&gt; {
    if **player_1 &gt; **player_2 {
        effect_out(
            message_write(Log("player 1 wins!".to_string())),
            FightOutcome::Player1Wins,
        )
    } else if **player_1 &lt; **player_2 {
        effect_out(
            message_write(Log("player 2 wins!".to_string())),
            FightOutcome::Player2Wins,
        )
    } else {
        effect_out(
            message_write(Log("fight came to a draw!".to_string())),
            FightOutcome::Draw,
        )
    }
}

/// This is a system! It defines the effects of a player 1 and 2 fighting (logging the result and despawning).
fn fight(
    player_1: Single&lt;(Entity, &amp;FightLevel), With&lt;Player&lt;1&gt;&gt;&gt;,
    player_2: Single&lt;(Entity, &amp;FightLevel), With&lt;Player&lt;2&gt;&gt;&gt;,
) -&gt; EffectOut&lt;(MessageWrite&lt;Log&gt;, Option&lt;EntityCommandDespawn&gt;), ()&gt; {
    let (player_1_entity, player_1_level) = *player_1;
    let (player_2_entity, player_2_level) = *player_2;

    // here's an EffectOut-returning call
    fight_outcome(player_1_level, player_2_level)
        // and now we're composing it w/ a closure processing the `out`
        .and_then(|outcome| match outcome {
            FightOutcome::Player1Wins =&gt; Some(entity_command_despawn(player_2_entity)),
            FightOutcome::Player2Wins =&gt; Some(entity_command_despawn(player_1_entity)),
            FightOutcome::Draw =&gt; None,
            // we can return an EffectOut here, but a mere Effect works too (in this case Option&lt;EntityCommandDespawn&gt;)
        })
    // we could continue composing it with more `.and_then`s if we had more output to process into effects.
}
<span class="boring">fn main() { bevy::ecs::system::assert_is_system(fight.pipe(affect)) }</span></code></pre></pre>
<p>You may notice that, if we <em>did</em> want to create the "despawn" effects in the <code>fight_outcome</code> system, we'd have to complicate its function signature with more <code>Entity</code> inputs.
This composition of <code>EffectOut</code>s keeps each function smaller and simpler, but allows for a grander logic that is much more complicated and powerful.</p>
<p>Rust users will recognize this API as being similar in name and purpose to <code>Option::and_then</code> and <code>Result::and_then</code>, and they'd roughly be correct.
Functional programmers, on the other hand, may recognize this API as being similar to a monad's bind operation.
It is <em>kind of</em> like that, but not quite.
While the <code>out: O</code> type gets mapped in a monadic way, the <code>effect: E</code> type changes to be a tuple of the new and old effects.
If it were truly monadic, only one type parameter (<code>out: O</code>) of <code>EffectOut</code> would be changed by bind, not both.</p>
<h3 id="effectoutand_extend"><a class="header" href="#effectoutand_extend"><code>EffectOut::and_extend</code></a></h3>
<p><a href="explanation/output-and-effect-composition.html#effectoutand_then"><code>and_then</code></a> may not be monadic, but there is another <a href="explanation/output-and-effect-composition.html#effectout"><code>EffectOut</code></a> composition function that is.
If the <code>effect: E</code> of the original <code>EffectOut</code> is an extendable iterator, and the new effect is an iterator, they can be concatenated with <code>and_extend</code>.</p>
<p>In this excerpt from the <code>sokoban</code> example, we take advantage of this to write a system with recursive logic.
This recursion is only possible because the recursive function's typing stays consistent.
I.e., the <code>effect: E</code> type parameter doesn't need to change with <code>and_extend</code> like it does with <code>and_then</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span><span class="boring">
</span><span class="boring">/// Component defining the logical position of a sokoban entity.
</span><span class="boring">#[derive(Debug, Default, Copy, Clone, Eq, PartialEq, Component, Deref, DerefMut)]
</span><span class="boring">pub struct Position(pub IVec2);
</span><span class="boring">
</span><span class="boring">/// Component defining the weight of a sokoban block (blocks too heavy cannot be pushed).
</span><span class="boring">#[derive(Debug, Default, Copy, Clone, Eq, PartialEq, Component, Deref, DerefMut)]
</span><span class="boring">pub struct Weight(pub u32);
</span><span class="boring">
</span>/// An observer event for triggering the push system
#[derive(Event)]
pub struct PushEntity {
    pub direction: IVec2,
    pub entity: Entity,
}

/// This recursive function creates the effects for pushing entities and also sums their weights.
fn push_and_weigh(
    positions: &amp;Query&lt;(Entity, &amp;Position, &amp;Weight)&gt;,
    position_pushed: Position,
    direction: IVec2,
) -&gt; EffectOut&lt;Vec&lt;EntityComponentsSet&lt;(Position,)&gt;&gt;, Weight&gt; {
    match positions
        .iter()
        .find(|(_, position, _)| **position == position_pushed)
    {
        // base case
        None =&gt; effect_out(vec![], Weight(0)),
        // recursive case
        Some((entity, _, weight)) =&gt; {
            let new_position = Position(*position_pushed + direction);

            push_and_weigh(&amp;positions, new_position.clone(), direction)
                // This is monadic EffectOut composition!
                .and_extend(|acc_weight| {
                    effect_out(
                        vec![entity_components_set(entity, (new_position,))],
                        Weight(*acc_weight + **weight),
                    )
                })
        }
    }
}

/// This observer system is the entrypoint for the above recursive pushing logic.
pub fn push(
    push: On&lt;PushEntity&gt;,
    positions: Query&lt;(Entity, &amp;Position, &amp;Weight)&gt;,
) -&gt; Vec&lt;EntityComponentsSet&lt;(Position,)&gt;&gt; {
    let (_first_entity, position_pushed, _weight) = positions.get(push.entity).unwrap();

    // We only use `EffectOut` for intermediate computation, and return a normal `Effect` in the system.
    let EffectOut {
        effect: pushes,
        out: weight,
    } = push_and_weigh(&amp;positions, *position_pushed, push.direction);

    if *weight &gt; 10 {
        // too heavy, do nothing.
        vec![]
    } else {
        pushes
    }
}
<span class="boring">
</span><span class="boring">/// Spawns an observer for the push system.
</span><span class="boring">pub fn spawn_push_observer() -&gt; impl Effect {
</span><span class="boring">    command_spawn(Observer::new(push.pipe(affect)))
</span><span class="boring">}
</span><span class="boring">fn main() { bevy::ecs::system::assert_is_system(push.pipe(affect)) }</span></code></pre></pre>
<p>This is a bit of a side-note, but notice how this system takes advantage of the fact that we <em>are not</em> actually performing side effects directly when using <code>Effect</code>s.
We create a hypothetical set of entity movements with <code>push_and_weigh</code>, but those movements aren't performed until the <code>affect</code> system runs.
So, we can decide to discard them for whatever reason between now and then (in this case, the reason being that the total weight is too heavy).</p>
<h3 id="effectoutand_then_compose"><a class="header" href="#effectoutand_then_compose"><code>EffectOut::and_then_compose</code></a></h3>
<p>So, <a href="explanation/output-and-effect-composition.html#effectoutand_then"><code>EffectOut::and_then</code></a> and <a href="explanation/output-and-effect-composition.html#effectoutand_extend"><code>EffectOut::and_extend</code></a> define two common ways to process output into more effects, and compose those effects.
What about less common effect composition strategies?</p>
<p>Well, <code>EffectOut::and_then_compose</code> simply allows the user to pass in an effect composition function, with a signature like <code>Fn(E1, E2) -&gt; E3</code>.
It is actually used internally by <code>and_then</code> and <code>and_extend</code>.
Some common effect composition functions are provided in the crate's <code>effect_composition</code> module.</p>
<h3 id="effectout-iterators"><a class="header" href="#effectout-iterators"><code>EffectOut</code> iterators</a></h3>
<p>Often, you will find yourself iterating through queries or event readers, and trying to produce effects during that iteration.
As you enjoy FP, you'll probably be trying to do this by mapping the iterator to effects.
This works well for mere <code>Effect</code>s, <a href="explanation/output-and-effect-composition.html#effect-iterators">you can just collect into a <code>Vec</code></a> and call it a day.
However, you may be dealing with <code>EffectOut</code>s, and a system returning <code>Vec&lt;EffectOut&gt;</code> cannot be piped into <code>affect</code>.</p>
<p>The crate provides a simple answer for this issue.
If the <code>effect</code> and <code>out</code> are both extendable iterators, then you can collect an iterator of <code>EffectOut</code>s into an <code>EffectOut</code> of iterators.</p>
<p>This is actually demonstrated in the code example of <a href="explanation/output-and-effect-composition.html#system-level-composition">the next section</a>.</p>
<h3 id="system-level-composition"><a class="header" href="#system-level-composition">System-level composition</a></h3>
<p><a href="explanation/output-and-effect-composition.html#effectoutand_then"><code>EffectOut::and_then</code></a>, <a href="explanation/output-and-effect-composition.html#effectoutand_extend"><code>EffectOut::and_extend</code></a>, and <a href="explanation/output-and-effect-composition.html#effectoutand_then_compose"><code>EffectOut::and_then_compose</code></a> are all methods for processing the <code>out</code> of an effect out into more effects and composing them.
Their functionality is also available at the system level, so you can return an <a href="explanation/output-and-effect-composition.html#effectout"><code>EffectOut</code></a> from one system, and then process its output into more effects with another.
These are the <code>in_and_then</code>, <code>in_and_extend</code>, and <code>in_and_then_compose</code> system combinators, respectively.
They each accept a system that takes the <code>out: O</code> type as system input and returns an effect, and they each return a system that accepts the whole <code>EffectOut</code> as system input and composes the effects.</p>
<p>Here, we use <code>in_and_then</code> to compose a system that creates explosions while calculating the explosion size with a system that plays the explosion sound effect.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span><span class="boring">use bevy::audio::Volume;
</span>#[derive(Deref, DerefMut, Component)]
struct InternalPressure(u32);

#[derive(Deref, DerefMut, Resource)]
struct ExplosionSound(Handle&lt;AudioSource&gt;);

fn explosion(
    explodable: Query&lt;(Entity, &amp;InternalPressure)&gt;,
) -&gt; EffectOut&lt;Vec&lt;EntityCommandDespawn&gt;, u32&gt; {
    explodable
        .iter()
        .flat_map(|(entity, internal_pressure)| {
            let explosion_size = internal_pressure.saturating_sub(100);

            if explosion_size &gt; 0 {
                Some(effect_out(entity_command_despawn(entity), explosion_size))
            } else {
                None
            }
        })
        .collect::&lt;EffectOut&lt;_, Vec&lt;_&gt;&gt;&gt;()
        // this maps the `out` value (functoriality!)
        .map(|sizes| sizes.into_iter().sum())
}

fn explosion_sound(In(explosion_size): In&lt;u32&gt;, sound: Res&lt;ExplosionSound&gt;) -&gt; Option&lt;impl Effect&gt; {
    if explosion_size &gt; 0 {
        Some(command_spawn((
            AudioPlayer::new(sound.clone()),
            PlaybackSettings::default().with_volume(Volume::Linear(explosion_size as f32)),
        )))
    } else {
        None
    }
}

fn main() {
    bevy::ecs::system::assert_is_system(explosion.pipe(in_and_then(explosion_sound)).pipe(affect));
}</code></pre></pre>
<p>Notice how the <code>explosion</code> and <code>explosion_sound</code> systems have completely disjoint system parameters.
Just like functions, the benefit of composing the effects of multiple systems in this way is often that you can simplify each individual system.</p>
<p>As mentioned before, if there remains an <code>out</code> type at the end of all this piping, then it will be passed out of the <code>affect</code> system, allowing for output processing to continue.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spawn-a-relationship-synchronously"><a class="header" href="#spawn-a-relationship-synchronously">Spawn a Relationship Synchronously</a></h1>
<p>Bevy relationships may be spawned using specialized commands, like <code>with_children</code> or <code>with_related_entities</code>.
<code>bevy_pipe_affect</code> APIs are more minimal, but these situations can still be handled ergonomically:</p>
<ol>
<li>Return an effect that spawns the entity that will be the <code>RelationshipTarget</code> with <code>command_spawn_and</code>. In the <code>Parent</code>/<code>ChildOf</code> relationship, this will become the <code>Parent</code> entity. That component does not need to be provided, it will be created by Bevy.</li>
<li>Provide a closure to the second argument of the <code>command_spawn_and</code> call that returns another <code>command_spawn-</code> effect that will spawn the <code>Relationship</code> entity. In the <code>Parent</code>/<code>ChildOf</code> relationship, this is the <code>ChildOf</code> entity. This time, you do need to provide that component with the <code>Entity</code> provided to the closure (this will be <code>RelationshipTarget</code> <code>Entity</code>, spawned in step 1).</li>
</ol>
<p>The <code>relationship</code> example does this, while also bundling some sprites/marker components:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Component)] struct Spinny;
</span>use bevy::prelude::*;
use bevy_pipe_affect::prelude::*;

fn spawn_relationship() -&gt; impl Effect {
    // We will give both entities a sprite, which we can load using this effect
    // We can use its handle to create more effects with a closure
    asset_server_load_and("player.png", |image_handle| {
        // Similarly, this effect will spawn our components
        // Then, we use the resulting Entity to create more effects with a closure
        command_spawn_and(
            (
                Spinny,
                Sprite::from_image(image_handle.clone()),
                Transform::from_scale(Vec3::splat(10.0)),
            ),
            |parent| {
                command_spawn((
                    ChildOf(parent), // This is where the relationship happens!
                    Spinny,
                    Sprite::from_image(image_handle),
                    Transform::from_xyz(20.0, 20.0, 0.0).with_scale(Vec3::splat(0.5)),
                ))
            },
        )
    })
}
<span class="boring">fn main() { bevy::ecs::system::assert_is_system(spawn_relationship.pipe(affect)) }</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spawn-and-trigger-an-observer"><a class="header" href="#spawn-and-trigger-an-observer">Spawn and Trigger an Observer</a></h1>
<p>While <code>bevy_pipe_affect</code> effects are somewhat minimal and don't include a <code>command_add_observer</code>, observers still integrate well with effects.</p>
<p>The following code examples are pulled from the <code>observer</code> cargo example.</p>
<ol>
<li>Create an event type (<code>InflateEvent</code> in this example)</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span><span class="boring">
</span>#[derive(Event)]
pub struct InflateEvent;
<span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">pub struct Inflatable;
</span><span class="boring">
</span><span class="boring">fn inflate(_event: On&lt;InflateEvent&gt;) -&gt; impl Effect + use&lt;&gt; {
</span><span class="boring">    components_set_filtered_with::&lt;_, _, With&lt;Inflatable&gt;&gt;(|(transform,): (Transform,)| {
</span><span class="boring">        (transform.with_scale(transform.scale * 1.1),)
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn spawn_observer() -&gt; impl Effect {
</span><span class="boring">    command_spawn(Observer::new(inflate.pipe(affect)))
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn trigger_observer(input: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;) -&gt; Option&lt;CommandTrigger&lt;InflateEvent&gt;&gt; {
</span><span class="boring">    if input.just_pressed(KeyCode::Space) {
</span><span class="boring">        Some(command_trigger(InflateEvent))
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">fn main() {}</span></code></pre></pre>
<ol start="2">
<li>Create a system that accepts an <code>On&lt;InflateEvent&gt;</code> and returns an effect that will be ran by the observer.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Event)]
</span><span class="boring">pub struct InflateEvent;
</span><span class="boring">
</span>#[derive(Component)]
pub struct Inflatable;

fn inflate(_event: On&lt;InflateEvent&gt;) -&gt; impl Effect + use&lt;&gt; {
    components_set_filtered_with::&lt;_, _, With&lt;Inflatable&gt;&gt;(|(transform,): (Transform,)| {
        (transform.with_scale(transform.scale * 1.1),)
    })
}
<span class="boring">
</span><span class="boring">pub fn spawn_observer() -&gt; impl Effect {
</span><span class="boring">    command_spawn(Observer::new(inflate.pipe(affect)))
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn trigger_observer(input: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;) -&gt; Option&lt;CommandTrigger&lt;InflateEvent&gt;&gt; {
</span><span class="boring">    if input.just_pressed(KeyCode::Space) {
</span><span class="boring">        Some(command_trigger(InflateEvent))
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">fn main() { bevy::ecs::system::assert_is_system(inflate.pipe(affect)) }</span></code></pre></pre>
<ol start="3">
<li>Create a system that spawns an <code>Observer</code> component with <code>command_spawn</code>, using the previous system <code>.pipe(affect)</code>-ed as the observer system.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Event)]
</span><span class="boring">pub struct InflateEvent;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">pub struct Inflatable;
</span><span class="boring">
</span><span class="boring">fn inflate(_event: On&lt;InflateEvent&gt;) -&gt; impl Effect + use&lt;&gt; {
</span><span class="boring">    components_set_filtered_with::&lt;_, _, With&lt;Inflatable&gt;&gt;(|(transform,): (Transform,)| {
</span><span class="boring">        (transform.with_scale(transform.scale * 1.1),)
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span>pub fn spawn_observer() -&gt; impl Effect {
    command_spawn(Observer::new(inflate.pipe(affect)))
}
<span class="boring">
</span><span class="boring">pub fn trigger_observer(input: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;) -&gt; Option&lt;CommandTrigger&lt;InflateEvent&gt;&gt; {
</span><span class="boring">    if input.just_pressed(KeyCode::Space) {
</span><span class="boring">        Some(command_trigger(InflateEvent))
</span><span class="boring">    } else {
</span><span class="boring">        None
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">fn main() { bevy::ecs::system::assert_is_system(spawn_observer.pipe(affect)) }</span></code></pre></pre>
<ol start="4">
<li>Trigger your observer with the <code>command_trigger</code> effect.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Event)]
</span><span class="boring">pub struct InflateEvent;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">pub struct Inflatable;
</span><span class="boring">
</span><span class="boring">fn inflate(_event: On&lt;InflateEvent&gt;) -&gt; impl Effect + use&lt;&gt; {
</span><span class="boring">    components_set_filtered_with::&lt;_, _, With&lt;Inflatable&gt;&gt;(|(transform,): (Transform,)| {
</span><span class="boring">        (transform.with_scale(transform.scale * 1.1),)
</span><span class="boring">    })
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn spawn_observer() -&gt; impl Effect {
</span><span class="boring">    command_spawn(Observer::new(inflate.pipe(affect)))
</span><span class="boring">}
</span><span class="boring">
</span>pub fn trigger_observer(input: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;) -&gt; Option&lt;CommandTrigger&lt;InflateEvent&gt;&gt; {
    if input.just_pressed(KeyCode::Space) {
        Some(command_trigger(InflateEvent))
    } else {
        None
    }
}
<span class="boring">fn main() { bevy::ecs::system::assert_is_system(trigger_observer.pipe(affect)) }</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p><meta http-equiv="Refresh" content="0; url='https://docs.rs/bevy_pipe_affect/0.1.0/bevy_pipe_affect'" /><!-- x-release-please-version --></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
