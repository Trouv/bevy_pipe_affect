<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Motivations - bevy_pipe_affect Book</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Alien Cake Addict Refactor</div></li><li class="chapter-item expanded affix "><li class="part-title">Explanation</li><li class="chapter-item expanded "><a href="../explanation/motivations.html" class="active"><strong aria-hidden="true">2.</strong> Motivations</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Output and Effect Composition</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Return Types</div></li><li class="chapter-item expanded affix "><li class="part-title">How-To Guides</li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Create a custom Effect</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Create a Relation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Create an Observer</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><div>API Reference</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">bevy_pipe_affect Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="motivations"><a class="header" href="#motivations">Motivations</a></h1>
<p>Scrawled here is basically a blog post on functional programming, Bevy, and why I made this library.
It may not be the most practical piece of documentation, but I hope it shines a light on some of the design choices for library users, and maybe even reaches out to others who are future FP+ECS enthusiasts.</p>
<h2 id="im-an-fp-shill-now"><a class="header" href="#im-an-fp-shill-now">I'm an FP shill now</a></h2>
<p>Here is a brief shill for writing FP Rust.
If you already are an FP shill, you can skip this.</p>
<p>Rust takes a lot of inspiration from purely functional languages like Haskell.
As a person who learned Rust before functional programming, I was intrigued to learn that most of its features that I found to be revelations turned out to be derivative.
Iterator chains, algebraic data types, sum-types used in place of <code>null</code> and exceptions, <code>?</code> operators, to name a few.
Similar things have been etched into purely functional languages for a long time.</p>
<p>I've written a lot of Rust professionally over the past few years, and gradually it has become obvious how beneficial it is to use these features.
Or, more than anything else, it has become obvious how beneficial it is to write pure functions with the aid of these features.</p>
<p>For the uninitiated, pure functions are those that are deterministic and have no side effects.
Like a function in mathematics, they are mere input and output, so they do not read or write anything from the state of the world at large.
A purely functional language, like Haskell, is one that only allows you to write pure functions.
This may seem limiting, but thanks to higher-order functions, plus the strength of FP's theoretical foundations in general, it really isn't.</p>
<p>Pure functions are easily unit tested, since you don't need to set up any state.
They are easy to compose without unexpected consequences.
Programs can become extremely complex through composition, but each component can be obvious and simple and predictable.
There's relief in functions that only have input and output, for both readers and writers of the code.</p>
<blockquote>
<p>Which function should perform this change?</p>
</blockquote>
<blockquote>
<p>Should the data this function uses be input or read from state?</p>
</blockquote>
<blockquote>
<p>Should the data this function calculates be output or written to state?</p>
</blockquote>
<p>If you're writing pure functions, these questions aren't just foregone conclusions, they are invalid.</p>
<p>So in my regular programming practice now, I go to great lengths to <em>at least</em> push the state reading/writing to the fringes of the program.
Even when designing a system of programs, I consider pushing the state to the fringes of the data flow at large.
This practice isn't that common in Bevy.</p>
<h2 id="practical-motivation"><a class="header" href="#practical-motivation">Practical motivation</a></h2>
<p>Now, like a true software-gamedev-hipster, I also shill Bevy.
The core framework of Bevy is an ECS among many great Rust ECSs, but I especially appreciate that its systems are mere functions.
Its system scheduler may be particularly attractive to FP shills as well.
It is declarative, it leverages higher-order functions for scheduling your systems, it provides system composition with piping and mapping, and it does its best to abstract away the parallel execution of systems safely.</p>
<p>However, the main way to interact with the world in vanilla Bevy is by writing systems that have side effects.
If you want to update a resource, you must parameterize a <code>ResMut</code>.
If you want to edit components in-place, you must query them <code>&amp;mut</code>-ably.
If you want to load an asset, you must interact with the internally mutable <code>AssetServer</code>.
Even if you do everything with <code>Commands</code>, not only do the intended effects require exclusive world access, you're still having a side effect on the command queue.</p>
<p>In my feable attempts to write more immutable systems, I would simply write systems that output messages, or bundles, and then have generic systems to handle these as pipe input and actually do the writing or spawning. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Component)]
</span><span class="boring">struct Health(u32);
</span>use bevy::prelude::*;

#[derive(Debug, PartialEq, Eq, Message)]
struct DeathMessage(Entity);

fn detect_deaths(query: Query&lt;(Entity, &amp;Health)&gt;) -&gt; Vec&lt;DeathMessage&gt; {
    query
        .iter()
        .flat_map(|(entity, health)| {
            if health.0 == 0 {
                Some(DeathMessage(entity))
            } else {
                None
            }
        })
        .collect()
}

fn write_messages&lt;M: Message&gt;(
    In(messages): In&lt;impl IntoIterator&lt;Item = M&gt;&gt;,
    mut writer: MessageWriter&lt;M&gt;,
) {
    messages.into_iter().for_each(|message| {
        writer.write(message);
    });
}

fn main() {
    bevy::ecs::system::assert_is_system(detect_deaths.pipe(write_messages));
}</code></pre></pre>
<p>So, in this example, I have a pure system <code>detect_deaths</code> that produces messages as output, and then a system that actually writes the messages <code>write_messages</code>.
I've gone from 0% of my systems being pure to 50%.
Since <code>write_messages</code> is generic, I can now write more pure systems that produce messages and reuse it.</p>
<p>Wouldn't it be nice if 100% of user-written systems could be pure?
If somebody provided all the systems you may ever need to do the &quot;writing&quot; so that you only have to worry about writing ECS effects declaratively?</p>
<p><code>bevy_pipe_affect</code> aims to provide these systems.
Or rather, a single system for all ECS mutation.
Her name is <code>affect</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">//! This test is mostly used to demonstrate testing in the book
</span><span class="boring">
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span><span class="boring">
</span>#[derive(Component)]
struct Health(u32);

#[derive(Debug, PartialEq, Eq, Message)]
struct DeathMessage(Entity);

fn detect_deaths(query: Query&lt;(Entity, &amp;Health)&gt;) -&gt; Vec&lt;MessageWrite&lt;DeathMessage&gt;&gt; {
    query
        .iter()
        .flat_map(|(entity, health)| {
            if health.0 == 0 {
                Some(DeathMessage(entity))
            } else {
                None
            }
        })
        .map(message_write)
        .collect()
}
<span class="boring">
</span><span class="boring">use bevy::ecs::system::RunSystemOnce;
</span><span class="boring">
</span><span class="boring">#[derive(Resource)]
</span><span class="boring">struct UnhealthyEntity(Entity);
</span><span class="boring">
</span><span class="boring">fn test_detect_deaths() {
</span><span class="boring">    let mut world = World::new();
</span><span class="boring">
</span><span class="boring">    // We still need to setup the initial state of the world.
</span><span class="boring">    let _setup = world
</span><span class="boring">        .run_system_once(
</span><span class="boring">            (|| {
</span><span class="boring">                command_spawn_and(Health(100), |_| {
</span><span class="boring">                    command_spawn_and(Health(0), |entity| {
</span><span class="boring">                        command_insert_resource(UnhealthyEntity(entity))
</span><span class="boring">                    })
</span><span class="boring">                })
</span><span class="boring">            })
</span><span class="boring">            .pipe(affect)
</span><span class="boring">            .pipe(ApplyDeferred),
</span><span class="boring">        )
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span><span class="boring">    // Now we can just assert against system output instead of state changes
</span><span class="boring">    let dead_entity_messages = world.run_system_once(detect_deaths).unwrap();
</span><span class="boring">
</span><span class="boring">    let UnhealthyEntity(entity) = world.get_resource::&lt;UnhealthyEntity&gt;().unwrap();
</span><span class="boring">
</span><span class="boring">    assert_eq!(
</span><span class="boring">        dead_entity_messages,
</span><span class="boring">        vec![message_write(DeathMessage(*entity))]
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn cargo_test_detect_deaths() {
</span><span class="boring">    test_detect_deaths()
</span><span class="boring">}
</span>
fn main() {
    bevy::ecs::system::assert_is_system(detect_deaths.pipe(affect));
}</code></pre></pre>
<p>Rather than returning a list of messages, <code>detect_deaths</code> now returns <code>MessageWrite</code>s, which is an <code>Effect</code>.
A <code>Vec</code> of <code>Effect</code>s is also an <code>Effect</code>.
Then, the <code>affect</code> system can take any <code>Effect</code> and do the necessary writing.
The user no longer has to write words like <code>mut</code> and <code>for</code>.</p>
<h2 id="theoretical-motivation"><a class="header" href="#theoretical-motivation">Theoretical motivation</a></h2>
<p>Bevy's system scheduling APIs are higher-order functions that allow you to register system-functions to the App.
We can basically think of these higher-order functions as taking functions with two arguments, a <code>SystemInput</code> and a <code>SystemParam</code>, and then having an output.
Technically there's an extra wrinkle to this for two reasons, but both are just a bit of sugar that carmelize down to these two arguments:</p>
<ul>
<li>the <code>SystemInput</code> can be omitted, but the Bevy scheduling traits just use the unit type <code>()</code> in these cases</li>
<li>the <code>SystemParam</code> can occupy more than 1 arguments to the function (or even 0), but the Bevy scheduling traits just convert these cases to a tuple <code>SystemParam</code></li>
</ul>
<p>This is elegant.
Our <code>SystemParam</code> argument not only serves as normal function input, but it also expresses to the higher-order scheduling APIs what <em>factor</em> of the world needs to be input to the system.
I say <em>factor</em> in the sense of algebraic data types.
In the language of algebraic data types, an ECS world is sort of like a <em>product</em> of component storages and resources, and our <code>SystemParam</code> identifies a <em>factor</em> of this <em>product</em>.
Again, the reality of Bevy is more complicated (this time, much more complicated) than this theoretical framework.</p>
<p>The <code>SystemParam</code> is even composable.
The <em>factor</em> of the world that a system gets as input can actually be a larger product of system params.
As in, it can be a tuple of other system params, which again, is what the sugar of multi-system-param-argument functions carmelizes into.
Pipe systems also leverage this fact by composing the <code>SystemParam</code>s of two systems into one.</p>
<p>So far nothing about this is functionally impure.
We have functions with two arguments and an output, the first argument is <code>SystemInput</code> which is parameterized by output of another system, the second argument is <code>SystemParam</code> which is parameterized by some data in the world.
The impurity arrives when we allow that data from the world to be mutable.
And of course, in vanilla Bevy, this is our only choice if we want to have any effect on the world other than heating up our computers.</p>
<p>Pure functions are just input and output.
We'd like to use the output instead of the side effects to have an effect on world data.
Hence the <code>Effect</code> types provided by <code>bevy_pipe_affect</code>, intended to be returned by user systems.</p>
<p><code>Effect</code>s, conceptually, are almost a reflection of <code>SystemParam</code>s.
Where <code>SystemParam</code>s allow systems to express what <em>factor</em> of the world should be read, <code>Effect</code>s allow systems to express what <em>factor</em> of the world should be written (and how).
Where <code>SystemParam</code>s have an identity in the form of <code>()</code> that requests no data from the world, <code>Effect</code>s also treat <code>()</code> as an identity that has no effect on the world.
Where <code>SystemParam</code>s offer composibility with product types and derives, <code>Effect</code>s offer composibility with product types, derives, and sum-types.</p>
<p>Yes, not only is <code>Effect</code> implemented for tuples of effects, it can also be derived for structs of <code>Effect</code>s and enums of <code>Effect</code>s.
The latter is not a reflection of <code>SystemParam</code> behavior.
After all, it's not that common that you want a system that accepts <em>either</em> system param A <em>or</em> system param B.
It's a different story for <code>Effect</code>s, as there are many situations where you want <em>either</em> effect A to happen <em>or</em> effect B to happen.
The composibility of <code>Effect</code>s is as algebraic as algebraic data types.</p>
<p>In vanilla Bevy, systems are functions that have a side effect on system params.
By <em>returning</em> effects instead, systems now have a more satisfying theoretical definition.
They are mappings from some <em>factor</em> of the world to a state transition.
Or, more abstractly, they are pure, deterministic declarations of world behavior.</p>
<h2 id="write-systems-as-pure-functions"><a class="header" href="#write-systems-as-pure-functions">Write systems as pure functions</a></h2>
<p>Of course, none of this is required with <code>bevy_pipe_affect</code>.
Nothing about it forces you to write pure systems, you could write an effectful system that pipes an <code>Effect</code> into the <code>affect</code> system.</p>
<p>If you choose to, you will enjoy many of the benefits of pure functions.
The consequences of your systems will be more obvious at a glance: they are in the system's return type.
If you need more specifics, their value will always be at the very bottom of your function body.
In general, these two facts make it more difficult for you to muddy your systems with effects.
You will be encouraged to separate the concerns of your systems even more than you already are.</p>
<p>And of course, unit tests are easier to write.
Instead of observing the effects your systems have on the Bevy world, you can just observe the output of your systems.
An example, testing the <code>detect_deaths</code> system written above:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">//! This test is mostly used to demonstrate testing in the book
</span><span class="boring">
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span><span class="boring">
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Health(u32);
</span><span class="boring">
</span><span class="boring">#[derive(Debug, PartialEq, Eq, Message)]
</span><span class="boring">struct DeathMessage(Entity);
</span><span class="boring">
</span><span class="boring">fn detect_deaths(query: Query&lt;(Entity, &amp;Health)&gt;) -&gt; Vec&lt;MessageWrite&lt;DeathMessage&gt;&gt; {
</span><span class="boring">    query
</span><span class="boring">        .iter()
</span><span class="boring">        .flat_map(|(entity, health)| {
</span><span class="boring">            if health.0 == 0 {
</span><span class="boring">                Some(DeathMessage(entity))
</span><span class="boring">            } else {
</span><span class="boring">                None
</span><span class="boring">            }
</span><span class="boring">        })
</span><span class="boring">        .map(message_write)
</span><span class="boring">        .collect()
</span><span class="boring">}
</span><span class="boring">
</span>use bevy::ecs::system::RunSystemOnce;

#[derive(Resource)]
struct UnhealthyEntity(Entity);

fn test_detect_deaths() {
    let mut world = World::new();

    // We still need to setup the initial state of the world.
    let _setup = world
        .run_system_once(
            (|| {
                command_spawn_and(Health(100), |_| {
                    command_spawn_and(Health(0), |entity| {
                        command_insert_resource(UnhealthyEntity(entity))
                    })
                })
            })
            .pipe(affect)
            .pipe(ApplyDeferred),
        )
        .unwrap();

    // Now we can just assert against system output instead of state changes
    let dead_entity_messages = world.run_system_once(detect_deaths).unwrap();

    let UnhealthyEntity(entity) = world.get_resource::&lt;UnhealthyEntity&gt;().unwrap();

    assert_eq!(
        dead_entity_messages,
        vec![message_write(DeathMessage(*entity))]
    );
}
<span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn cargo_test_detect_deaths() {
</span><span class="boring">    test_detect_deaths()
</span><span class="boring">}
</span><span class="boring">fn main() { test_detect_deaths() }</span></code></pre></pre>
<p>Over all, game logic just becomes easier to reason about, especially <em>ex post facto</em>.
I hope you enjoy writing systems this way, and that they bring you more joy when the time comes for you to maintain them.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
