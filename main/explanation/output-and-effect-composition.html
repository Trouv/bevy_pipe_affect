<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Output and Effect Composition - bevy_pipe_affect Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">bevy_pipe_affect Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="output-and-effect-composition"><a class="header" href="#output-and-effect-composition">Output and Effect Composition</a></h1>
<p>This chapter will cover the ways that effects compose, starting with the most basic and getting more advanced.</p>
<h2 id="combined-effects"><a class="header" href="#combined-effects">Combined effects</a></h2>
<p>The canonical form of "effect composition" is the combined effect, which is simply a tuple of effects.
The <code>Effect</code> trait is implemented for tuples where each element of the tuple also implements <code>Effect</code>.
The <code>affect</code> system will perform their effects from left to right.</p>
<p>So, if you want a system that has 2 or more effects of heterogenous type, you can just return their tuple:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span>#[derive(Resource)]
struct Score(u32);

fn setup() -&gt; impl Effect {
    (
        command_spawn(Camera2d::default()),
        command_insert_resource(Score(0)),
    )
}
<span class="boring">fn main() { bevy::ecs::system::assert_is_system(setup.pipe(affect)) }</span></code></pre></pre>
<h2 id="effect-iterators"><a class="header" href="#effect-iterators">Effect iterators</a></h2>
<p><code>Effect</code> is implemented for a couple of important iterators, <code>Option</code> and <code>Vec</code>.
There's also the <code>affect_many</code> effect, which can wrap any iterator.</p>
<p>So, if you want a system that has 2 or more effects of homogenous type, you can return them as a <code>Vec</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">//! This test is mostly used to demonstrate testing in the book
</span><span class="boring">
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span><span class="boring">
</span>#[derive(Component)]
struct Health(u32);

#[derive(Debug, PartialEq, Eq, Message)]
struct DeathMessage(Entity);

fn detect_deaths(query: Query&lt;(Entity, &amp;Health)&gt;) -&gt; Vec&lt;MessageWrite&lt;DeathMessage&gt;&gt; {
    query
        .iter()
        .flat_map(|(entity, health)| {
            if health.0 == 0 {
                Some(DeathMessage(entity))
            } else {
                None
            }
        })
        .map(message_write)
        .collect()
}
<span class="boring">
</span><span class="boring">use bevy::ecs::system::RunSystemOnce;
</span><span class="boring">
</span><span class="boring">#[derive(Resource)]
</span><span class="boring">struct UnhealthyEntity(Entity);
</span><span class="boring">
</span><span class="boring">fn test_detect_deaths() {
</span><span class="boring">    let mut world = World::new();
</span><span class="boring">
</span><span class="boring">    // We still need to setup the initial state of the world.
</span><span class="boring">    let _setup = world
</span><span class="boring">        .run_system_once(
</span><span class="boring">            (|| {
</span><span class="boring">                command_spawn_and(Health(100), |_| {
</span><span class="boring">                    command_spawn_and(Health(0), |entity| {
</span><span class="boring">                        command_insert_resource(UnhealthyEntity(entity))
</span><span class="boring">                    })
</span><span class="boring">                })
</span><span class="boring">            })
</span><span class="boring">            .pipe(affect)
</span><span class="boring">            .pipe(ApplyDeferred),
</span><span class="boring">        )
</span><span class="boring">        .unwrap();
</span><span class="boring">
</span><span class="boring">    // Now we can just assert against system output instead of state changes
</span><span class="boring">    let dead_entity_messages = world.run_system_once(detect_deaths).unwrap();
</span><span class="boring">
</span><span class="boring">    let UnhealthyEntity(entity) = world.get_resource::&lt;UnhealthyEntity&gt;().unwrap();
</span><span class="boring">
</span><span class="boring">    assert_eq!(
</span><span class="boring">        dead_entity_messages,
</span><span class="boring">        vec![message_write(DeathMessage(*entity))]
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[test]
</span><span class="boring">fn cargo_test_detect_deaths() {
</span><span class="boring">    test_detect_deaths()
</span><span class="boring">}
</span><span class="boring">fn main() { bevy::ecs::system::assert_is_system(detect_deaths.pipe(affect)); }</span></code></pre></pre>
<h2 id="effectout"><a class="header" href="#effectout">EffectOut</a></h2>
<p><code>bevy_pipe_affect</code> sort of hijacks bevy's system piping.
So, at first glance, it may seem like there's no way to go about typical system pipe usage while making effects.
The <code>EffectOut</code> type aims to give system piping back to the people.
It also provides some composibility of its own that may be useful beyond systems.
More on this in the following sections.</p>
<p>Structurally, it's just an <code>effect</code> field containing an effect, and an <code>out</code> field containing additional output.</p>
<p>You may be interested to know that the higher-order systems provided by <code>bevy_pipe_affect</code> actually only ever expect a type that can convert into <code>EffectOut</code>, not just a mere <code>Effect</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span>#[derive(Resource)]
struct Score(u32);

#[derive(Deref, DerefMut, Resource)]
struct StartTime(f32);

fn update_score(time: Res&lt;Time&gt;, start_time: Res&lt;StartTime&gt;) -&gt; EffectOut&lt;ResSet&lt;Score&gt;, f32&gt; {
    let level_time = time.elapsed_secs() - **start_time;
    effect_out(res_set(Score(level_time as u32)), level_time)
}

fn main() {
    bevy::ecs::system::assert_is_system(update_score.pipe(affect))
}</code></pre></pre>
<p>Notice that we can still pipe <code>update_score</code> into <code>affect</code>, even though <code>update_score</code> returns an <code>EffectOut</code> instead of an <code>Effect</code>.
However, be aware that <code>affect</code> will actually have an output too; the <code>f32</code> is passed along.
This would prevent us from scheduling the system (without further piping to drop the <code>f32</code>).
However, it is inconsequential if the <code>out</code> type is <code>()</code>.</p>
<h3 id="effectoutand_then"><a class="header" href="#effectoutand_then"><code>EffectOut::and_then</code></a></h3>
<p><a href="#effectout"><code>EffectOut</code></a>s compose in a few different ways, with the main goal of letting users process the <code>out</code> field while continuing to collect effects.
For example, the <code>and_then</code> method takes a function for processing the <code>out</code> into another <code>Effect</code>/<code>EffectOut</code>, and returns an <code>EffectOut</code> with the <code>effect</code> <a href="#combined-effects">combining the original/new effect</a>, and an <code>out</code> being the new output.</p>
<p>This code example shows <code>and_then</code> being used to process the <code>EffectOut</code> returned by one function into more effects:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span><span class="boring">// A simple marker component for players.
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Player&lt;const N: usize&gt;;
</span><span class="boring">// A logical component for player level.
</span><span class="boring">#[derive(Component, Deref, DerefMut)]
</span><span class="boring">struct FightLevel(u32);
</span><span class="boring">/// A simple message we can write with effects.
</span><span class="boring">#[derive(Message)]
</span><span class="boring">struct Log(String);
</span>/// Will be used as an intermediate result of the fight logic.
enum FightOutcome {
    Player1Wins,
    Player2Wins,
    Draw,
}

/// This is not a system! It describes the logic for the upcoming fight system and also has a logging effect.
fn fight_outcome(
    player_1: &amp;FightLevel,
    player_2: &amp;FightLevel,
) -&gt; EffectOut&lt;MessageWrite&lt;Log&gt;, FightOutcome&gt; {
    if **player_1 &gt; **player_2 {
        effect_out(
            message_write(Log("player 1 wins!".to_string())),
            FightOutcome::Player1Wins,
        )
    } else if **player_1 &lt; **player_2 {
        effect_out(
            message_write(Log("player 2 wins!".to_string())),
            FightOutcome::Player2Wins,
        )
    } else {
        effect_out(
            message_write(Log("fight came to a draw!".to_string())),
            FightOutcome::Draw,
        )
    }
}

/// This is a system! It defines the effects of a player 1 and 2 fighting (logging the result and despawning).
fn fight(
    player_1: Single&lt;(Entity, &amp;FightLevel), With&lt;Player&lt;1&gt;&gt;&gt;,
    player_2: Single&lt;(Entity, &amp;FightLevel), With&lt;Player&lt;2&gt;&gt;&gt;,
) -&gt; EffectOut&lt;(MessageWrite&lt;Log&gt;, Option&lt;EntityCommandDespawn&gt;), ()&gt; {
    let (player_1_entity, player_1_level) = *player_1;
    let (player_2_entity, player_2_level) = *player_2;

    // here's an EffectOut-returning call
    fight_outcome(player_1_level, player_2_level)
        // and now we're composing it w/ a closure processing the `out`
        .and_then(|outcome| match outcome {
            FightOutcome::Player1Wins =&gt; Some(entity_command_despawn(player_2_entity)),
            FightOutcome::Player2Wins =&gt; Some(entity_command_despawn(player_1_entity)),
            FightOutcome::Draw =&gt; None,
            // we can return an EffectOut here, but a mere Effect works too (in this case Option&lt;EntityCommandDespawn&gt;)
        })
    // we could continue composing it with more `.and_then`s if we had more output to process into effects.
}
<span class="boring">fn main() { bevy::ecs::system::assert_is_system(fight.pipe(affect)) }</span></code></pre></pre>
<p>You may notice that, if we <em>did</em> want to create the "despawn" effects in the <code>fight_outcome</code> system, we'd have to complicate its function signature with more <code>Entity</code> inputs.
This composition of <code>EffectOut</code>s keeps each function smaller and simpler, but allows for a grander logic that is much more complicated and powerful.</p>
<p>Rust users will recognize this API as being similar in name and purpose to <code>Option::and_then</code> and <code>Result::and_then</code>, and they'd roughly be correct.
Functional programmers, on the other hand, may recognize this API as being similar to a monad's bind operation.
It is <em>kind of</em> like that, but not quite.
While the <code>out: O</code> type gets mapped in a monadic way, the <code>effect: E</code> type changes to be a tuple of the new and old effects.
If it were truly monadic, only one type parameter (<code>out: O</code>) of <code>EffectOut</code> would be changed by bind, not both.</p>
<h3 id="effectoutand_extend"><a class="header" href="#effectoutand_extend"><code>EffectOut::and_extend</code></a></h3>
<p><a href="#effectoutand_then"><code>and_then</code></a> may not be monadic, but there is another <a href="#effectout"><code>EffectOut</code></a> composition function that is.
If the <code>effect: E</code> of the original <code>EffectOut</code> is an extendable iterator, and the new effect is an iterator, they can be concatenated with <code>and_extend</code>.</p>
<p>In this excerpt from the <code>sokoban</code> example, we take advantage of this to write a system with recursive logic.
This recursion is only possible because the recursive function's typing stays consistent.
I.e., the <code>effect: E</code> type parameter doesn't need to change with <code>and_extend</code> like it does with <code>and_then</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span><span class="boring">
</span><span class="boring">/// Component defining the logical position of a sokoban entity.
</span><span class="boring">#[derive(Debug, Default, Copy, Clone, Eq, PartialEq, Component, Deref, DerefMut)]
</span><span class="boring">pub struct Position(pub IVec2);
</span><span class="boring">
</span><span class="boring">/// Component defining the weight of a sokoban block (blocks too heavy cannot be pushed).
</span><span class="boring">#[derive(Debug, Default, Copy, Clone, Eq, PartialEq, Component, Deref, DerefMut)]
</span><span class="boring">pub struct Weight(pub u32);
</span><span class="boring">
</span>/// An observer event for triggering the push system
#[derive(Event)]
pub struct PushEntity {
    pub direction: IVec2,
    pub entity: Entity,
}

/// This recursive function creates the effects for pushing entities and also sums their weights.
fn push_and_weigh(
    positions: &amp;Query&lt;(Entity, &amp;Position, &amp;Weight)&gt;,
    position_pushed: Position,
    direction: IVec2,
) -&gt; EffectOut&lt;Vec&lt;EntityComponentsSet&lt;(Position,)&gt;&gt;, Weight&gt; {
    match positions
        .iter()
        .find(|(_, position, _)| **position == position_pushed)
    {
        // base case
        None =&gt; effect_out(vec![], Weight(0)),
        // recursive case
        Some((entity, _, weight)) =&gt; {
            let new_position = Position(*position_pushed + direction);

            push_and_weigh(&amp;positions, new_position.clone(), direction)
                // This is monadic EffectOut composition!
                .and_extend(|acc_weight| {
                    effect_out(
                        vec![entity_components_set(entity, (new_position,))],
                        Weight(*acc_weight + **weight),
                    )
                })
        }
    }
}

/// This observer system is the entrypoint for the above recursive pushing logic.
pub fn push(
    push: On&lt;PushEntity&gt;,
    positions: Query&lt;(Entity, &amp;Position, &amp;Weight)&gt;,
) -&gt; Vec&lt;EntityComponentsSet&lt;(Position,)&gt;&gt; {
    let (_first_entity, position_pushed, _weight) = positions.get(push.entity).unwrap();

    // We only use `EffectOut` for intermediate computation, and return a normal `Effect` in the system.
    let EffectOut {
        effect: pushes,
        out: weight,
    } = push_and_weigh(&amp;positions, *position_pushed, push.direction);

    if *weight &gt; 10 {
        // too heavy, do nothing.
        vec![]
    } else {
        pushes
    }
}
<span class="boring">
</span><span class="boring">/// Spawns an observer for the push system.
</span><span class="boring">pub fn spawn_push_observer() -&gt; impl Effect {
</span><span class="boring">    command_spawn(Observer::new(push.pipe(affect)))
</span><span class="boring">}
</span><span class="boring">fn main() { bevy::ecs::system::assert_is_system(push.pipe(affect)) }</span></code></pre></pre>
<p>This is a bit of a side-note, but notice how this system takes advantage of the fact that we <em>are not</em> actually performing side effects directly when using <code>Effect</code>s.
We create a hypothetical set of entity movements with <code>push_and_weigh</code>, but those movements aren't performed until the <code>affect</code> system runs.
So, we can decide to discard them for whatever reason between now and then (in this case, the reason being that the total weight is too heavy).</p>
<h3 id="effectoutand_then_compose"><a class="header" href="#effectoutand_then_compose"><code>EffectOut::and_then_compose</code></a></h3>
<p>So, <a href="#effectoutand_then"><code>EffectOut::and_then</code></a> and <a href="#effectoutand_extend"><code>EffectOut::and_extend</code></a> define two common ways to process output into more effects, and compose those effects.
What about less common effect composition strategies?</p>
<p>Well, <code>EffectOut::and_then_compose</code> simply allows the user to pass in an effect composition function, with a signature like <code>Fn(E1, E2) -&gt; E3</code>.
It is actually used internally by <code>and_then</code> and <code>and_extend</code>.
Some common effect composition functions are provided in the crate's <code>effect_composition</code> module.</p>
<h3 id="effectout-iterators"><a class="header" href="#effectout-iterators"><code>EffectOut</code> iterators</a></h3>
<p>Often, you will find yourself iterating through queries or event readers, and trying to produce effects during that iteration.
As you enjoy FP, you'll probably be trying to do this by mapping the iterator to effects.
This works well for mere <code>Effect</code>s, <a href="#effect-iterators">you can just collect into a <code>Vec</code></a> and call it a day.
However, you may be dealing with <code>EffectOut</code>s, and a system returning <code>Vec&lt;EffectOut&gt;</code> cannot be piped into <code>affect</code>.</p>
<p>The crate provides a simple answer for this issue.
If the <code>effect</code> and <code>out</code> are both extendable iterators, then you can collect an iterator of <code>EffectOut</code>s into an <code>EffectOut</code> of iterators.</p>
<p>This is actually demonstrated in the code example of <a href="#system-level-composition">the next section</a>.</p>
<h3 id="system-level-composition"><a class="header" href="#system-level-composition">System-level composition</a></h3>
<p><a href="#effectoutand_then"><code>EffectOut::and_then</code></a>, <a href="#effectoutand_extend"><code>EffectOut::and_extend</code></a>, and <a href="#effectoutand_then_compose"><code>EffectOut::and_then_compose</code></a> are all methods for processing the <code>out</code> of an effect out into more effects and composing them.
Their functionality is also available at the system level, so you can return an <a href="#effectout"><code>EffectOut</code></a> from one system, and then process its output into more effects with another.
These are the <code>in_and_then</code>, <code>in_and_extend</code>, and <code>in_and_then_compose</code> system combinators, respectively.
They each accept a system that takes the <code>out: O</code> type as system input and returns an effect, and they each return a system that accepts the whole <code>EffectOut</code> as system input and composes the effects.</p>
<p>Here, we use <code>in_and_then</code> to compose a system that creates explosions while calculating the explosion size with a system that plays the explosion sound effect.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_pipe_affect::prelude::*;
</span><span class="boring">use bevy::audio::Volume;
</span>#[derive(Deref, DerefMut, Component)]
struct InternalPressure(u32);

#[derive(Deref, DerefMut, Resource)]
struct ExplosionSound(Handle&lt;AudioSource&gt;);

fn explosion(
    explodable: Query&lt;(Entity, &amp;InternalPressure)&gt;,
) -&gt; EffectOut&lt;Vec&lt;EntityCommandDespawn&gt;, u32&gt; {
    explodable
        .iter()
        .flat_map(|(entity, internal_pressure)| {
            let explosion_size = internal_pressure.saturating_sub(100);

            if explosion_size &gt; 0 {
                Some(effect_out(entity_command_despawn(entity), explosion_size))
            } else {
                None
            }
        })
        .collect::&lt;EffectOut&lt;_, Vec&lt;_&gt;&gt;&gt;()
        // this maps the `out` value (functoriality!)
        .map(|sizes| sizes.into_iter().sum())
}

fn explosion_sound(In(explosion_size): In&lt;u32&gt;, sound: Res&lt;ExplosionSound&gt;) -&gt; Option&lt;impl Effect&gt; {
    if explosion_size &gt; 0 {
        Some(command_spawn((
            AudioPlayer::new(sound.clone()),
            PlaybackSettings::default().with_volume(Volume::Linear(explosion_size as f32)),
        )))
    } else {
        None
    }
}

fn main() {
    bevy::ecs::system::assert_is_system(explosion.pipe(in_and_then(explosion_sound)).pipe(affect));
}</code></pre></pre>
<p>Notice how the <code>explosion</code> and <code>explosion_sound</code> systems have completely disjoint system parameters.
Just like functions, the benefit of composing the effects of multiple systems in this way is often that you can simplify each individual system.</p>
<p>As mentioned before, if there remains an <code>out</code> type at the end of all this piping, then it will be passed out of the <code>affect</code> system, allowing for output processing to continue.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../explanation/motivations.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../how-to-guides/spawn-a-relationship-synchronously.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../explanation/motivations.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../how-to-guides/spawn-a-relationship-synchronously.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
